// Author: Reza Jelveh
// Include the Ruby headers and goodies
#include "ruby.h"

// Defining a space for information and references about the module to be stored internally
VALUE HexCoding = Qnil;

// let's fill out the lookup table for fast access
char hex_chars[0x10] = {
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};
// the lookup table has 0-9 instead of ascii 0-9 and 10-16 instead of ascii a-f/A-F
char lookup_table[0xff]={
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,  // 0x30 - 0x39 -> 0 - 9
  0x07,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,  // 0x41 - 0x46 -> 10 - 15 (a-f)
  0x0B,0x0C,0x0D,0x0E,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x0B,  // 0x61 - 0x66 -> 10 - 15 (a-f)
  0x0C,0x0D,0x0E,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00
};

// Prototype for the initialization method - Ruby calls this, not you
void Init_hexcoding();

// Prototype for our method 'encode' - methods are prefixed by 'method_' here
VALUE method_encode(VALUE self, VALUE ruby_string);
VALUE method_decode(VALUE self, VALUE ruby_string);

// The initialization method for this module
void Init_hexcoding() {
	int i,j;

  HexCoding = rb_define_module("HexCoding");
  rb_define_method(HexCoding, "encode", method_encode, 1);
  rb_define_method(HexCoding, "decode", method_decode, 1);

	/* this can be used to generate the lookup table
	// lets fill the lookup table
	for(i=0; i<=9; i++){
		j = 0x30 + i;
		lookup_table[j] = i;
	}

	// lets fill the alpha chars
	for(i=1; i<=6; i++){
		j = 0x40 + i;
		lookup_table[j] = 9+i;
		j = 0x60 + i;
		lookup_table[j] = 9+i;
	}

	printf("char lookup_table[0xff]={");
  for(i=0; i<0xff; i++){
    printf("0x%02X,", lookup_table[i]);
  }
  printf("};");
  */
}

VALUE method_decode(VALUE self, VALUE hex_string){
  const int length = RSTRING(hex_string)->len>>1;
	const char* c_string = RSTRING(hex_string)->ptr;
	VALUE dec_string = rb_str_new(NULL, length);
	char *foo = RSTRING(dec_string)->ptr;
	char *hex = RSTRING(hex_string)->ptr;
	int i,j;

	for(i=0, j=0; j < length; i+=2, j++){
		foo[j]  = (lookup_table[hex[i]] << 4)  | lookup_table[hex[i+1]];
	}

	return dec_string;
}

// Our 'encode' method..
VALUE method_encode(VALUE self, VALUE ruby_string){
	const int length = RSTRING(ruby_string)->len;
	const char* c_string = RSTRING(ruby_string)->ptr;
  VALUE hex_string = rb_str_new(NULL, length<<1);
	char *foo = RSTRING(hex_string)->ptr;
	int i,j;

	// pseudo code temp_string[i] = to_hex(original_string[i].to_i);

	for(i=0, j=0; j < length; i+=2, j++){
		foo[i+1] = hex_chars[c_string[j]&0x0f];
		foo[i]   = hex_chars[(c_string[j]&0xf0)>>4];
	}

	return hex_string;
}
